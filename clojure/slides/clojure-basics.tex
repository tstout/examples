% 
% Compile with 'pdflatex -shell-escape clojure-basics.tex'
% I use the mactex distro of Tex. https://tug.org/mactex/
% 

\documentclass{beamer}

\usetheme{Madrid}    

\usepackage{listings}                                   
\usepackage{hyperref}
\usepackage{graphicx}                                 
\usepackage{tabularx}
\usepackage{microtype}
\usepackage[T1]{fontenc}
\usepackage[scaled]{beramono}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{pgfplots}
\usepackage{dirtytalk}
\usepackage{tikz}
\usetikzlibrary{tikzmark,fit}

%\usepackage{enumitem}
\pgfplotsset{compat=1.6} 

\newcommand\Small{\fontsize{5}{5.2}\selectfont}
\newcommand*\LSTfont{\Small\ttfamily\SetTracking{encoding=*}{-60}\lsstyle}
\renewcommand{\footnotesize}{\tiny}

\hypersetup{colorlinks=color, linkcolor=black}
\definecolor{OliveGreen}{rgb}{0,0.6,0}
\graphicspath{{./images/}}
% 
% Turn off beamer nav stuff...
% 
\setbeamertemplate{navigation symbols}{}


\input{lst-config/clojure-config}
\begin{document}

\begin{frame}
  \frametitle{Clojure}
  \center{
    \includegraphics[scale=.40]{Clojure-Logo}
  }
\end{frame}

\frame{
  \frametitle {Clojure}
  \say{The objective for Clojure can be summarized most succinctly as: I
    wanted a language as acceptable as Java or C\#, but supporting a much 
    simpler programming model, to use for the kinds of information system 
    development I had been doing professionally.}

  \rightline{{\rm -- Rich Hickey}}
}

\frame{
  \frametitle{Origins of Clojure - Church}
  \begin{columns}
    \begin{column}{.49\textwidth}
      \includegraphics[scale=.50]{church}
    \end{column}
    \begin{column}{.49\textwidth}
      \itemize{
      \item Alonzo Church - 1936
      \item $\lambda$ Calculus
       \footnote{\href{https://www.ics.uci.edu/~lopes/teaching/inf212W12/readings/church.pdf}
         {An Unsolvable Problem of Elementary Number Theory}}
      }

    \end{column}
  \end{columns}
}

%\resetcounter[footnote]
%\setcounter{footnote}{0} 

\frame{
  \frametitle{Origins of Clojure - McCarthy}
  \begin{columns}
    \begin{column}{.49\textwidth}
      \includegraphics[width=\textwidth,height=\textheight,keepaspectratio=true]{john-mccarthy}
    \end{column}
    \begin{column}{.49\textwidth}
      % \vspace {4 cm}
      \itemize{
      \item John McCarthy - 1958
      \item
        OriginalPaper - 1960
        \footnote{\href{http://www-formal.stanford.edu/jmc/recursive.html}{Original Paper}}
      \item 
        Influenced by Church \& IPL 
        \footnote{\href{https://en.wikipedia.org/wiki/Information_Processing_Language}{
            IPL Overview}}
        \vspace {4 cm}
      }
    \end{column}
  \end{columns}
}

\frame{
  \frametitle{Origins of Clojure - Steve Russell - 1958}
  \begin {columns}
    \begin{column}{.49\textwidth}
      \begin{itemize}
      \item[] \includegraphics[scale=1.25]{steve-russell}
      \item[] First Lisp interpreter
      \end{itemize}
    \end{column}
    \begin{column}{.49\textwidth}
      \begin{itemize}
      \item[]\includegraphics[scale=1.35]{ibm-704}
      \item[]IBM-704
      \end{itemize}
    \end{column}
  \end{columns}
}

\frame{
  \frametitle{Notable Attributes of the Original Lisp}
  \begin{itemize}
  \item Conditionals
  \item A function type
  \item Recursion
  \item New variable concept - values have types, not variables. Assigning/binding variables copies pointers, not what it points to.
  \item Garbage Collection
  \end{itemize}
}

\frame{
 \frametitle{Many Lisp Implementations}
  % 
  % TODO add more?
  % 
  \begin{itemize}
  \item Maclisp - Late 1960s \footnote{MIT, not Apple}
  \item Scheme - 1970s (Guile, Racket, Chicken) 
  \item Emacs LISP - 1976
  \item Common LISP - 1984 (CLISP, CMUCL, SBCL, ABCL, MKCL)
  \item AutoLISP - 1986
  \item Apple Dylan - 1992
  \item Clojure - 2007
  \item Arc - 2008
  \end{itemize}
}

\frame{
  \frametitle{Origins of Clojure - Communicating Sequential Processes (CSP) - 1977}
  \begin {columns}
    \begin{column}{.49\textwidth}
      \begin{itemize}
      \item[] \includegraphics[scale=.75]{Tony_Hoare}
      \item[] Tony Hoare
      \end{itemize}
    \end{column}
    \begin{column}{.49\textwidth}
      \begin{itemize}
        \item[] \href{https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf}{\color{blue}{
            CSP}}
        \item[] Foundation of core.async
      \end{itemize}
    \end{column}
  \end{columns}
}


\frame{
  \frametitle{Origin of Clojure - Persistent Data Structures - 1986}
  \begin {columns}
    \begin{column}{.49\textwidth}
      \begin{itemize}
      \item James R. Drisco
      \item Neil Sarna
      \item Daniel D. Sleat
      \item Robert E. Tawa
      \end{itemize}
    \end{column}
    \begin{column}{.49\textwidth}
      \begin{itemize}
        
      \item \href{http://www.cs.cmu.edu/~sleator/papers/another-persistence.pdf}{\color{blue}{
            Making Data Structures Persistent}}
      \end{itemize}
    \end{column}
  \end{columns}
}


\frame{
  \frametitle{Origins of Clojure - Bagwell - 2001}
  \begin {columns}
    \begin{column}{.49\textwidth}
      \includegraphics[scale=1]{phil-bagwell}
      \vspace {.25 cm}
    \end{column}
    \begin{column}{.49\textwidth}
      \begin{itemize}
      \item \href
        {https://infoscience.epfl.ch/record/64398/files/idealhashtrees.pdf}{\color{blue}{
            Ideal Hash Trees}}
      \item Hash Array Mapped Trie (HAMT)
      \end{itemize}

    \end{column}
  \end{columns}
  Phil Bagwell
}

\frame{
  \frametitle{Origins of Clojure - Hash Array Mapped Trie}
  \center { $O(log_{32} n)$ Effectively Constant Time}
  %\vspace {.25 cm}
  \center{
    \begin{tikzpicture}
      \begin{semilogxaxis}[
        grid=both,
        grid style={line width=.1pt, draw=gray!10},
        major grid style={line width=.2pt,draw=gray!50},
        xmin=1,
        xmax=1000000000,
        domain=1:1000000000,
        ylabel=$\log_{32} n$,
        xlabel=n]
        % 
        % recall that log32(x) = log10(x) / log10(32)
        % 
        \addplot[
        red,
        ]
        {log10(x) / log10(32)};
      \end{semilogxaxis}
    \end{tikzpicture}
  }
  %\vspace {.25 cm}
  %\center{ \tiny{Effectively Constant Time} }
  \begin{tiny}
  \href {https://gist.github.com/brymck/8266276}
    {\color {blue}{clojure Big-O}}
  \end{tiny}

}


\frame{
  \frametitle{Origins of Clojure - Hickey 2007}
  \center{
    \includegraphics[scale=.45]{rhickey}
  }
  Rich Hickey
}

\frame{
  \frametitle{Yet Another Lisp?}
  \begin{itemize}
    % \pause
  \item Immutability is the Default 
    % \pause
  \item Persistent Collections
    % \pause
  \item Unified Sequences (Lists, Maps, Vectors, Sets)
    % \pause
  \item Concurrency Support
    % \pause
  \item Designed to rely on (and embrace) a host platform
    % \pause
  \item JVM
    % \pause
  \item Javascipt (Browser and Node)
    % \pause
  \item CLR (.NET)

    % 
    % Mention clojurescript has laid the ground-work of clojure-in-clojure
    % 
    % \item Embraces the host platform (Predominantly the JVM)
    %   \pause
    % \item Clojurescript brings Clojure to the browser/node environment
    %   \pause
  \end{itemize}
}

\setcounter{footnote}{0} 
\frame{
  \frametitle{Clojure's Worldview}
  \begin{itemize}
  \item Data Centric 
  \item Data should not be hidden behind objects
  \item Mutable state makes concurrency, and most other things hard
  \item VMs not Operating Systems
  \item Fight with the army we have \footnote{Borrowed from Stuart Halloway} (parasitic language - rely on a
    host env)
  \item Disciplined Evolution
  \item There is wisdom in history
  \end{itemize}
}

% Consider borrowing some ideas from this: 
%https://www.reddit.com/r/Clojure/comments/mcuq3s/clojure_in_a_nutshell_by_james_trunk/?utm_source=share&utm_medium=web2x&context=3

\frame{
  \frametitle {Obligatory Quote}
  \say{Some programming languages have been created primarily to demonstrate
    a particular nugget of academia or to explore certain theories of
    computation. Clojure is not one of these. Rich Hickey has said on
    numerous occasions that Clojure has value to the degree that it lets
    you build interesting and useful applications.}
  \rightline{{\rm --- The Joy of Clojure}}
}

\frame{
  \frametitle {Obligatory Quote}
  \say {By relieving the brain of all unnecessary work, a good notation sets
    it free to concentrate on more advanced problems.}
  \rightline{{\rm --- Alfred North Whitehead}}
}

% TODO - revaluate if this table is helpful for an introduction.
% Update - I don't think it is. Should probably Remove for now...
% 
\begin{frame}
  \frametitle{Core Clojure Syntax}
  \begin{tabularx}{\textwidth}{ |X|X|X| }
    \hline
    \emph{Function invocation} & (fn-name fn-arg...)  &  (foo 1 2 3) \\ 
    \hline
    \emph{Keyword} & :key  & :foo \\ 
    \hline
    \emph{Map} &    \{\}  & \{:a 1 :b 2 :c 3\} \\ 
    \hline
    \emph{Set} &    \#\{\} & \#\{1 2 3\} \\ 
    \hline
    \emph{Vector} & []  & [1 2 3] \\
    \hline
    \emph{List} & '() & '(1 2 3) \\
    \hline
    \emph{Regex} & \#"" & \#"*.clj" \\    
    \hline
  \end{tabularx}

  \vspace{.5cm}
  Syntax is essentially (fn/macro-name arg1 arg2 ...) where arguments can
  be functions, constants, or data literals. 
\end{frame}

\begin{frame}[fragile]
  \frametitle{Core Clojure Syntax}
  \center{
    \includegraphics[scale=.25]{clojure-form}
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{Core Clojure Syntax - Data Literals}
  \begin{minted}[fontsize=\small]{clojure}
;;keyword
:jenny

;;list
'(1 2 3 4 5)

;;vector
[8 6 7 5 309]                                  

;;map
{:first-name "Tommy" :last-name "Tutone"}      

;;set
#{19 81}                                       

;;regex
#"^(.+)@(.+)$"
\end{minted}  
\end{frame}

\begin{frame}[fragile]
  \frametitle{Core Clojure Syntax - Data Literals}
  \begin{minted}[fontsize=\tiny]{java}
package example.prototypes;

public class Empty {
}
  \end{minted}
  \begin{minted}[fontsize=\tiny]{clojure}
;;composite structure

{:header        {:magic 3405691582 :major-version 0 :minor-version 52}
 :constant-pool [{:constant-type :c-method-ref :class-index 3 :name-and-type-index 10}
                 {:constant-type :c-class :name-index 11}
                 {:constant-type :c-class :name-index 12}
                 {:constant-type :c-utf8 :str "<init>"}
                 {:constant-type :c-utf8 :str "()V"}
                 {:constant-type :c-utf8 :str "Code"}
                 {:constant-type :c-utf8 :str "LineNumberTable"}
                 {:constant-type :c-utf8 :str "SourceFile"}
                 {:constant-type :c-utf8 :str "Empty.java"}
                 {:constant-type :c-name-and-type :descriptor-index 4 :name-index 5}
                 {:constant-type :c-utf8 :str "example/prototypes/Empty"}
                 {:constant-type :c-utf8 :str "java/lang/Object"}]
 :access-flags  33
 :this-class    2
 :super-class   3
 :interfaces    []
 :fields        []
 :methods       [{:access-flags     1
                  :name-index       4
                  :descriptor-index 5
                  :attributes       [{:attribute-name-index 6
                                      :info                 [0 1 0 1 0 0 0 5 183 0 1 177 0 0
                                                             0 1 0 7 0 0 0 6 0 1 0 0 0 6]}]}]
 :attributes    [{:attribute-name-index 8 :info [0 9]}]}

\end{minted}  
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functions}
  Typical function definition:
  \begin{minted}[fontsize=\normalsize,escapeinside=||]{clojure}
    (defn foo 
      "optional multiline doc comment"
      {:optional :metadata-map} 
      [arg1 arg2]
      {:optional :pre/post-conditions-map}
      (...implementation...))
  \end{minted}

  \vspace{1 cm}

%% [autogobble,fontfamily=myfont,escapeinside=||}{c}

  This is an anonymous function (sum of its args):
  \begin{minted}[fontsize=\normalsize]{clojure}
    (fn [a b] (+ a b))   
  \end{minted}
  \vspace{1 cm}

  An abbreviated equivalent:
  \begin{minted}[fontsize=\normalsize]{clojure}
    #(+ %1 %2)
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Multi-arity Functions}
  \begin{minted}[fontsize=\normalsize]{clojure}
  
  (defn make-set 
    ([x]   #{x}) 
    ([x y] #{x y}))

  (make-set 1)
  => #{1}

  (make-set 1 2)
  => #{1 2}
  
  (make-set 1 2 3)
  => ArityException Wrong number of args passed...
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Variadic Functions}
  \begin{minted}[fontsize=\normalsize]{clojure}
  (defn mean [& args]
    (/ (reduce + args) (count args)))

  (mean 2 1 1 2)
  => 3/2

  (mean)
  => ArithmeticException Divide by zero

  (mean 10 20 30 40)
  => 25
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pre/Post Conditions}
  \begin{minted}[fontsize=\normalsize]{clojure}
  (defn constrained-fn [f x]
    {:pre  [(pos? x) (fn? f)]
     :post [(= % (* 2 x))]}
    (f x))

  (constrained-fn #(* 2 %) 2)
  => 4

  (constrained-fn #(float (* 2 %)) 2)
  => 4.0

  (constrained-fn #(* 3 %) 2)
  => java.lang.Exception: Assert failed: (= % (* 2 x))
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Collections as Functions}
  \begin{minted}[fontsize=\small]{clojure}
    ;; Keywords are functions which take a map as an
    ;; argument
    (:a {:a 1 :b 2 :c 3})
    => 1

    (:d {:a 1 :b 2 :c 3})
    => nil

    ;; Sets are functions of their elements that return the 
    ;; matched element or nil: 
    (#{:a :b :c :d} :c)
    => :c

    (#{:a :b :c :d} :e)
    => nil

  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Collections as Functions}
  \begin{minted}[fontsize=\small]{clojure}
    ;; Vectors are functions which take an integer index and 
    ;; return the element at that position.
    ([1 2 3] 0)
    => 1

    ([1 2 3] 2)
    => 3

    ;; Maps are functions which accept an argument used as a key 
    ;; to find an item in the map. Nil is returned if the key
    ;; does not exist in the map.
    ({:a 1 :b 2 :c 3} :c)
    => 3

    ({:a 1 :b 2} :e)
    => nil

  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functions - Metadata}
  \begin{minted}[linenos=false,fontsize=\footnotesize]{clojure}
    (ns testing-examples.core
      (:require [clojure.test :refer [is]]))

    (defn divisible?
      "Is n divisble by d?"
      {:test (fn []
               (is (divisible? 49 7))
               (is (not (divisible? 48 7)))
               (is (divisible? 5 0)))}
      [n d]
      (zero? (try 
               (mod n d)
             (catch Exception _ 0))))
      
   ;; #' is sugar for (var ...)

   (meta #'divisible?)  
   => {:arglists ([n d])
       :doc "Is n divisble by d?"
       :test #function[testing-examples.core/fn--7295]
       :line 4
       :column 1
       :file "/Users/tstout/basics/testing/src/testing_examples/core.clj"
       :name divisible?
       :ns #namespace[testing-examples.core]}
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{Namespaces}
  \itemize{
  \item Group Related Functions Together
  \item Clojure's Fundamental unit of Organization
  \item Dynamic - Can be Inspected/Manipulated at Runtime
  }  
\end{frame}

\begin{frame}[fragile]
  \frametitle{Namespace Example}
  \begin{minted}[linenos=false,fontsize=\small]{clojure}
  (ns myproj.db
   (:import [org.h2.tools Server]
            [java.net InetAddress]
            [org.h2.jdbcx JdbcConnectionPool])
   (:require [kratzen.config :refer [load-res load-config]]
             [com.stuartsierra.component :as component]
             [clojure.tools.logging :as log]
             [clojure.java.jdbc :as jdbc])) 
  
  ;; --- Var definitions for this namespace --

  (defn host-name []
    (let [host (.. InetAddress getLocalHost getHostName)]
      (log/infof "Using host name %s for DB..." host)
      host))
  

  \end{minted}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Multimethods - Polymorphic Functions}
  \begin{minted}[linenos=false,fontsize=\footnotesize]{clojure}
  ;; Note: In this example, the keyword :Shape is being used as the
  ;; dispatch function, as keywords are functions of maps
  ;; area is a function defined by an open set of methods - a multimethod
  ;; dispatch is determined by the value returned by :Shape 
  ;; (a keyword used as a function)

  (defmulti area :Shape)

  ;; the method that will be called when :Shape returns :Rect
  (defmethod area :Rect [r]
    (* (:wd r) (:ht r)))
  
  ;; the method that will be called when :Shape returns :Circle
  (defmethod area :Circle [c]
    (* Math/PI (:radius c) (:radius c)))
  
  ;; the method that will be called when no other dispatch applies
  (defmethod area :default [x] :oops)
  
  ;; information vs objects
  (def r {:Shape :Rect, :wd 4, :ht 13})
  (def c {:Shape :Circle, :radius 12})
  => (area r)
  52
  => (area c)
  452.3893421169302
  => (area {})
  :oops
  \end{minted}
  \Tiny\begin{verbatim}
  This example taken from History of Clojure  
  \end{verbatim}
\normalsize
  
\end{frame}


\begin{frame}[fragile]
  \frametitle{Host Interop}
  \begin{minted}[fontsize=\small]{clojure}
;; instance method invocation
=> (.toUpperCase "fred")
"FRED"

;; classnames yield Class values
=> (.getName String)
"java.lang.String"

;; constructor syntax 'Classname.'
(def p (java.awt.Point. 1 2))

;; field accessor
=> (.-x p)
1

;; static method
=> (System/getProperty "java.vm.version")
"25.151-b12"

;; static field
=> Math/PI
3.141592653589793
  \end{minted}
%% Mention bean?
  \Tiny\begin{verbatim}
  This example taken from History of Clojure  
  \end{verbatim}
\end{frame}

\frame{
  \frametitle{spec}
  \begin{center}
    \begin{Large}
      A standard, expressive, powerful, integrated system
    \end{Large}
  \end{center}
  \begin{center}
    \begin{Large}
      for specification and testing
    \end{Large}
  \end{center}
  \begin {columns}
    \begin{column}{.49\textwidth}
      \begin{itemize}
        \item Example Data Generation
        \item Conformance
        \item Validation
      \end{itemize}
    \end{column}
    \begin{column}{.49\textwidth}
      \begin{itemize}
      \item Documentation
      \item Generative Testing
      \item Destructuring
      \end{itemize}
    \end{column}
  \end{columns}
  \vspace{3 cm}


  \begin{tiny}
  \href {https://clojure.org/about/spec}
    {\color {blue}{rationale}}

  \href {https://clojure.org/guides/spec}
    {\color {blue}{guide}}
  \end{tiny}
}

\begin{frame}
  \frametitle{Interactive Development}
  \begin{itemize}
  \item Build your Code Interactively
  \item Build your Code Dynamically (no restarts required)
  \item Quick Feedback
  \item Experiment with Ease
  \item Editor Integrated with Language Runtime
  \end{itemize}
  \begin{tiny}
  \href {https://www.youtube.com/watch?v=gIoadGfm5T8}
    {\color {blue}{REPL Driven Development}}
  \end{tiny}
  
\end{frame}

\begin{frame}
  \frametitle{Clojure}
  \center{
    \includegraphics[scale=.20]{clojure-cave}
  }

\end{frame}

%https://clojure.org/api/cheatsheet

\frame {
  \frametitle{Resources}
  \begin{itemize}

  \item \href {https://www.clojure-toolbox.com/}
    {\color {blue}{The Clojure Toolbox}}

  \item \href {https://clojure.org/api/cheatsheet}
    {\color {blue}{Cheatsheet}}

  \item \href {https://clojure.org/about/history}
    {\color {blue}{History of Clojure}}

 \item \href {https://www.braveclojure.com/}
    {\color {blue}{CLOJURE for the BRAVE and TRUE}}
  
  \item \href{https://github.com/edn-format/edn}
    {\color {blue}{Extensible Data Notation (EDN)}}

  \item \href{https://clojure.org/guides/destructuring}
    {\color {blue}{Destructuring Guide}}

  \item \href{https://clojure.org/guides/deps_and_cli}
    {\color {blue}{Deps and CLI Guide}}

  \item \href{https://reagent-project.github.io/}
    {\color {blue}{Reagent (clojurescript + React = Fun!)}}

  \item \href{https://clojure.org/community/companies}
    {\color {blue}{Companies Using Clojure}}

  \item \href{http://www.paulgraham.com/avg.html}
    {\color {blue}{Beating The Averages}}

  \item \href{https://github.com/tstout/examples/blob/master/clojure/slides/clojure-basics.tex}
       {\color {blue}{Source Code for this document}}

  \end{itemize}
  }

% 
% Let over lambda example...can simplify with #() - but not as readable IMO.
% 
% (defn db-layer [db-connection]
% (let [db-operations {:save (fn [obj] (save db-connection obj))
% :delete (fn [obj] (delete db-connection obj))
% :query (fn [query] (query db-connection query))}]
% (fn [operation & params]
% (-> (db-operations operation) (apply params)))))
\end{document}
